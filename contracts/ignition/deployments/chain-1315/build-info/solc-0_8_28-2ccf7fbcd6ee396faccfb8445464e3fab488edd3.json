{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-2ccf7fbcd6ee396faccfb8445464e3fab488edd3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Vault.sol": "project/contracts/Vault.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Vault.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\ninterface IEarnings {\r\n    function addUserEarning(address user, string calldata ipId) external payable;\r\n    function addProtocolEarning() external payable;\r\n}\r\n\r\ncontract Vault {\r\n    address public owner;\r\n    address public earningsContract;\r\n    \r\n    // Fee constants (in basis points: 1% = 100, 0.5% = 50)\r\n    uint256 public constant IP_OWNER_FEE = 100; // 1%\r\n    uint256 public constant PROTOCOL_FEE = 50; // 0.5%\r\n    uint256 public constant FEE_DENOMINATOR = 10000; // 100%\r\n    \r\n    // Mapping: user => ipId => token balance\r\n    mapping(address => mapping(string => uint256)) public balances;\r\n    \r\n    // Mapping: ipId => total supply\r\n    mapping(string => uint256) public totalSupply;\r\n    \r\n    // Mapping: ipId => owner address\r\n    mapping(string => address) public ipOwners;\r\n    \r\n    event Buy(\r\n        address indexed user,\r\n        string ipId,\r\n        uint256 amountTokens,\r\n        uint256 amountPaid,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    event Sell(\r\n        address indexed user,\r\n        string ipId,\r\n        uint256 amountTokens,\r\n        uint256 amountReceived,\r\n        uint256 timestamp\r\n    );\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n    \r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set the earnings contract address (can only be set once)\r\n     * @param _earningsContract Address of the Earnings contract\r\n     */\r\n    function setEarningsContract(address _earningsContract) external onlyOwner {\r\n        require(earningsContract == address(0), \"Earnings contract already set\");\r\n        require(_earningsContract != address(0), \"Invalid address\");\r\n        earningsContract = _earningsContract;\r\n    }\r\n    \r\n    /**\r\n     * @dev Register IP owner (should be called when IP is first created)\r\n     * @param ipId IP asset ID\r\n     * @param ipOwner Owner of the IP asset\r\n     */\r\n    function registerIPOwner(string calldata ipId, address ipOwner) external {\r\n        require(bytes(ipId).length > 0, \"IP ID required\");\r\n        require(ipOwner != address(0), \"Invalid owner address\");\r\n        require(ipOwners[ipId] == address(0), \"IP already registered\");\r\n        \r\n        ipOwners[ipId] = ipOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Buy IP tokens\r\n     * @param ipId The IP asset ID being purchased\r\n     * @param amountTokens Number of tokens to buy\r\n     */\r\n    function buy(string calldata ipId, uint256 amountTokens) external payable {\r\n        require(msg.value > 0, \"Payment required\");\r\n        require(amountTokens > 0, \"Amount must be greater than 0\");\r\n        require(bytes(ipId).length > 0, \"IP ID required\");\r\n        require(ipOwners[ipId] != address(0), \"IP not registered\");\r\n        \r\n        // Calculate fees\r\n        uint256 ipOwnerFee = (msg.value * IP_OWNER_FEE) / FEE_DENOMINATOR; // 1%\r\n        uint256 protocolFee = (msg.value * PROTOCOL_FEE) / FEE_DENOMINATOR; // 0.5%\r\n        \r\n        // Transfer fees to Earnings contract if set\r\n        if (earningsContract != address(0) && (ipOwnerFee > 0 || protocolFee > 0)) {\r\n            IEarnings earnings = IEarnings(earningsContract);\r\n            \r\n            // Transfer IP owner fee\r\n            if (ipOwnerFee > 0) {\r\n                earnings.addUserEarning{value: ipOwnerFee}(ipOwners[ipId], ipId);\r\n            }\r\n            \r\n            // Transfer protocol fee\r\n            if (protocolFee > 0) {\r\n                earnings.addProtocolEarning{value: protocolFee}();\r\n            }\r\n        }\r\n        \r\n        // Update user balance\r\n        balances[msg.sender][ipId] += amountTokens;\r\n        \r\n        // Update total supply\r\n        totalSupply[ipId] += amountTokens;\r\n        \r\n        emit Buy(msg.sender, ipId, amountTokens, msg.value, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Sell IP tokens back to vault\r\n     * @param ipId The IP asset ID being sold\r\n     * @param amountTokens Number of tokens to sell\r\n     * @param expectedRefund Expected refund amount (before fees)\r\n     */\r\n    function sell(string calldata ipId, uint256 amountTokens, uint256 expectedRefund) external {\r\n        require(amountTokens > 0, \"Amount must be greater than 0\");\r\n        require(bytes(ipId).length > 0, \"IP ID required\");\r\n        require(balances[msg.sender][ipId] >= amountTokens, \"Insufficient balance\");\r\n        require(ipOwners[ipId] != address(0), \"IP not registered\");\r\n        \r\n        // Calculate fees on the refund amount\r\n        uint256 ipOwnerFee = (expectedRefund * IP_OWNER_FEE) / FEE_DENOMINATOR; // 1%\r\n        uint256 protocolFee = (expectedRefund * PROTOCOL_FEE) / FEE_DENOMINATOR; // 0.5%\r\n        uint256 netRefund = expectedRefund - ipOwnerFee - protocolFee;\r\n        \r\n        require(address(this).balance >= expectedRefund, \"Insufficient vault balance\");\r\n        \r\n        // Update user balance\r\n        balances[msg.sender][ipId] -= amountTokens;\r\n        \r\n        // Update total supply\r\n        totalSupply[ipId] -= amountTokens;\r\n        \r\n        // Transfer fees to Earnings contract if set\r\n        if (earningsContract != address(0) && (ipOwnerFee > 0 || protocolFee > 0)) {\r\n            IEarnings earnings = IEarnings(earningsContract);\r\n            \r\n            // Transfer IP owner fee\r\n            if (ipOwnerFee > 0) {\r\n                earnings.addUserEarning{value: ipOwnerFee}(ipOwners[ipId], ipId);\r\n            }\r\n            \r\n            // Transfer protocol fee\r\n            if (protocolFee > 0) {\r\n                earnings.addProtocolEarning{value: protocolFee}();\r\n            }\r\n        }\r\n        \r\n        // Refund user (net amount after fees)\r\n        (bool success, ) = msg.sender.call{value: netRefund}(\"\");\r\n        require(success, \"Refund failed\");\r\n        \r\n        emit Sell(msg.sender, ipId, amountTokens, netRefund, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n     * @dev Get user's balance for a specific IP\r\n     * @param user User address\r\n     * @param ipId IP asset ID\r\n     */\r\n    function getBalance(address user, string calldata ipId) external view returns (uint256) {\r\n        return balances[user][ipId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total supply for a specific IP\r\n     * @param ipId IP asset ID\r\n     */\r\n    function getTotalSupply(string calldata ipId) external view returns (uint256) {\r\n        return totalSupply[ipId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get IP owner address\r\n     * @param ipId IP asset ID\r\n     */\r\n    function getIPOwner(string calldata ipId) external view returns (address) {\r\n        return ipOwners[ipId];\r\n    }\r\n    \r\n    /**\r\n     * @dev Get vault's native token balance\r\n     */\r\n    function getVaultBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    /**\r\n     * @dev Emergency withdraw (owner only)\r\n     * @param to Recipient address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function emergencyWithdraw(address payable to, uint256 amount) external onlyOwner {\r\n        require(address(this).balance >= amount, \"Insufficient balance\");\r\n        (bool success, ) = to.call{value: amount}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n    \r\n    /**\r\n     * @dev Transfer ownership\r\n     * @param newOwner New owner address\r\n     */\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Fallback to receive native tokens\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
      }
    }
  }
}